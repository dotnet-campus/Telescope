using dotnetCampus.Telescope.SourceGenerator.Test.Utils;
using dotnetCampus.Telescope.SourceGeneratorAnalyzers;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace dotnetCampus.Telescope.SourceGenerator.Test;

[TestClass]
public class ExportTypeToMethodTest
{
    /// <summary>
    /// 测试包含两个类型的 ValueTuple 返回值的情况
    /// public class + private static method
    /// </summary>
    // private partial IEnumerable<(Type, Func<DemoLib1.F1> xxx)> ExportF1Enumerable();
    [TestMethod]
    public void TestTwoTypeValueTupleWithPublicClassAndPrivateStaticMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

public partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    private static partial IEnumerable<(Type, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));

        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            public partial class TestCode
            {
                private static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute());

                }
            }
        }
        */
        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("public partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("private static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());"));
        Assert.AreEqual(true, sourceText.Contains("yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());"));
        Assert.AreEqual(true, sourceText.Contains("yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());"));
        Assert.AreEqual(true, sourceText.Contains("yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute), () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute());"));
    }

    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况
    /// 包含所引用的程序集的类型
    /// public class + private static method
    /// </summary>
    // private static partial IEnumerable<(Type, F1Attribute xx, Func<DemoLib1.F1> xxx)> ExportFooEnumerable()
    [TestMethod]
    public void TestTreeTypeValueTupleIncludeReferencesWithPublicClassAndPrivateStaticMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

public partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    private static partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            public partial class TestCode
            {
                private static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());

                }
            }
        }
         */
        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("public partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("private static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
        // 不带 Attribute 的类型不会生成代码
        Assert.AreEqual(false, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute()"));
    }

    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况，不包含所引用的程序集的类型
    /// public class + private method
    /// </summary>
    [TestMethod]
    public void TestTreeTypeValueTupleWithPublicClassAndPrivateMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

public partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = false)]
    private partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            public partial class TestCode
            {
                private partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());

                }
            }
        }


        */
        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("public partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("private partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));

        // 由于 F2 和 F3 都是引用的程序集中的类型，所以不会生成代码
        Assert.AreEqual(false, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(false, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
        // 不带 Attribute 的类型不会生成代码
        Assert.AreEqual(false, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute()"));
    }


    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况
    /// public class + private method
    /// </summary>
    [TestMethod]
    public void TestTreeTypeValueTupleIncludeReferencesWithPublicClassAndPrivateMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

public partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    private partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            public partial class TestCode
            {
                private partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());

                }
            }
        }
        */

        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("public partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("private partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
        // 不带 Attribute 的类型不会生成代码
        Assert.AreEqual(false, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.FooWithoutAttribute()"));
    }

    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况
    ///  class + public method
    /// </summary>
    [TestMethod]
    public void TestTreeTypeValueTupleIncludeReferencesWithInternalClassAndPublicMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    public partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            partial class TestCode
            {
                public partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());

                }
            }
        }
        */

        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("public partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
    }

    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况
    /// internal class + public static method
    /// </summary>
    [TestMethod]
    public void TestTreeTypeValueTupleIncludeReferencesWithInternalClassAndPublicStaticMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

internal partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    public static partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();
        // 生成代码如下
        /*
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     此代码由工具生成。
        //
        //     对此文件的更改可能会导致不正确的行为，并且如果
        //     重新生成代码，这些更改将会丢失。
        // </auto-generated>
        //------------------------------------------------------------------------------

        #define GENERATED_CODE



        namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets
        {
            internal partial class TestCode
            {
                public static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()
                {
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2());
                        yield return (typeof(global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3), new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute()
                        {

                        }, () => new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3());

                }
            }
        }
        */

        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("internal partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("public static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
    }

    /// <summary>
    /// 测试包含三个类型的 ValueTuple 返回值的情况
    /// public class + protected static method
    /// </summary>
    [TestMethod]
    public void TestTreeTypeValueTupleIncludeReferencesWithPublicClassAndProtectedStaticMethod()
    {
        var compilation = TestCodeProvider.CreateCompilation();
        compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(@"
using dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1;

using System;
using System.Collections.Generic;

namespace dotnetCampus.Telescope.SourceGenerator.Test.Assets;

public partial class TestCode
{
    [dotnetCampus.Telescope.TelescopeExportAttribute(IncludeReferences = true)]
    protected static partial IEnumerable<(Type, F1Attribute xx, Func<dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable();
}"));
        var generator = new TelescopeExportTypeToMethodIncrementalGenerator();

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);
        Assert.AreEqual(0, diagnostics.Length);
        var generatedTrees = driver.GetRunResult().GeneratedTrees;
        // 包含两个生成的文件，第一个是 TelescopeExportAttribute 定义，第二个才是对此类型生成的代码
        Assert.AreEqual(2, generatedTrees.Length);
        var generatedTree = generatedTrees[1];
        var sourceText = generatedTree.GetText().ToString();

        // 跟随定义的方法生成了代码
        Assert.AreEqual(true, sourceText.Contains("public partial class TestCode"));
        Assert.AreEqual(true, sourceText.Contains("protected static partial global::System.Collections.Generic.IEnumerable<(global::System.Type, global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1Attribute xx, global::System.Func<global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib1.F1> xxx)> ExportFooEnumerable()"));

        // 包含生成了 F2 和 F3 等几个类型
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGenerator.Test.Assets.CurrentFoo()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib2.F2()"));
        Assert.AreEqual(true, sourceText.Contains("new global::dotnetCampus.Telescope.SourceGeneratorAnalyzers.TestLib3.F3()"));
    }
}